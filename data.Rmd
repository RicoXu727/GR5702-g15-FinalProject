# Data

## Sources

(Describe the data sources: who is responsible for collecting the data? How is it collected? If there were a choice of options, explain how you chose. (It's ok if there some repetition with the previous chapter. Chapter 2 will reflect your thinking at the time of the proposal and Chapter 3 will represent the state of the project when it is complete.)

Provide some basic information about the data: types of variables, number of records, etc.

Describe any issues / problems with the data, either known or that you discover.)

(suggested: approximately 1 page)

In this [2019 Iowa Liquor Sales dataset](%5Bhttps://data.iowa.gov/Sales-Distribution/2019-Iowa-Liquor-Sales/38x4-vs5h),](<https://data.iowa.gov/Sales-Distribution/2019-Iowa-Liquor-Sales/38x4-vs5h>),) there are very few missing values. There are as many as 24 attributes, which include Date of consumption, Store Name, Category Name, Vendor name and more, detailing every single alcohol consumption. In addition, this dataset is rich in Catigorical Data as well as Numerical Data, and we can use as many kinds of charts as possible to explore the data in the subsequent analysis.

The dataset was collected from grocery stores, liquor stores, convenience stores and so on which has Class E liquor license. If we encounter some questions, we can simply submit contact request form in Iowa government website. How to use the data? We can export it as csv file and import to Rstudio. The dataset consists of 2.38 million points with 24 columns. In this particular project, we will discard the identification information such as "Invoice Number", "Store Adress", "Item Number", etc.

## Cleaning / transformation

(Describe the process of getting the data into a form in which you could work with it in R if relevant. If your code does not lend itself to being including in the `.Rmd` Â file, provide a link to the folder or file(s) that contain(s) that code. (If your data did not require any cleaning or transformation before beginning EDA simply state that.))

(suggested: approximately 1/2 page)

Since the source data file size is too large, the source file is over 500MB, which exceeds the limit of GitHub upload, we first used Python to randomly sample one-tenth of the data as the research data for this project.

```{r}
library(dplyr)
library(tibble)
library(tidyr)
library(ggplot2)
library(forcats)
```

```{r}
# data <- readr::read_csv("/Users/ricole/Desktop/Leetcode-Note/2019_Iowa_Liquor_Sales_sample.csv", show_col_types = FALSE)
data <- readr::read_csv("https://raw.githubusercontent.com/RicoXu727/Leetcode-Note/main/2019_Iowa_Liquor_Sales_sample.csv", show_col_types = FALSE)
```

Second, we eliminated some redundant column data according to the need of the study.

```{r}
drop <- c("Invoice/Item Number","Address", "Store Location", "Volume Sold (Liters)")
subdata = data[,!(names(data) %in% drop)]
```

```{r}
set.seed(10)
x <- sampledData <- sample(1:nrow(subdata), 1000)
headdata <- subdata[x, ]
```

To better present the pattern of missing values on the graph, we rename the column of the data.

```{r}
colnames(headdata)[2] ="StNum"
colnames(headdata)[3] ="StName"
colnames(headdata)[6] ="CoNum"
colnames(headdata)[8] ="Cat"
colnames(headdata)[9] ="CatName"
colnames(headdata)[10] ="VenNum"
colnames(headdata)[11] ="VenName"
colnames(headdata)[12] ="ItNum"
colnames(headdata)[13] ="ItDes"
colnames(headdata)[15] ="BV"
colnames(headdata)[16] ="SBC"
colnames(headdata)[17] ="SBR"
colnames(headdata)[18] ="BS"
colnames(headdata)[19] ="Sale"
colnames(headdata)[20] ="VS"
# headdata <- headdata %>% 
#             rename("Store Number" = "StNum","Store Name" = "StName", "County Number" = "CoNum", "Category" = "Cat", "Category Name" = "CatName","Vendor Number" = "VenNum","Vendor Name" = "VenName", "Item Number" = "ItNum","Item Description" = "ItDes","Bottle Volumn (ml)" = "BV", "State Bottle Cost" = "SBC","Bottle Sold" = "BS","Sale (Dollars)" = "Sale","Volume Sold (Gallons)" = "VS")
```

## Missing value analysis

Describe any patterns you discover in missing values. If no values are missing, graphs should still be included showing that.

(suggested: 2 graphs plus commentary)

To explore the presence of missing values, we first coun how many missing values exist for each attribute.

```{r}
colSums(is.na(subdata)) %>%
  sort(decreasing = TRUE)
```

```{r}
library(naniar)

vis_miss(headdata)
```

```{r}
NoAttBasePlot <- function (legend, size_plot_height, Main_bar_plot, Matrix_plot, 
    hratios, Size_plot, query_legend, set_metadata, set_metadata_plots, 
    newpage) {
    top <- 1
    bottom <- 100
    if ((!is.null(legend)) && (query_legend != tolower("none"))) {
        if (query_legend == tolower("top")) {
            top <- 3
            bottom <- 102
            legend_top <- 1
            legend_bottom <- 3
            size_plot_height <- (size_plot_height + 2)
        }
        else if (query_legend == tolower("bottom")) {
            legend_top <- 101
            legend_bottom <- 103
        }
    }
    if (is.null(set_metadata)) {
        matrix_and_mainbar_right <- 100
        matrix_and_mainbar_left <- 21
        size_bar_right <- 20
        size_bar_left <- 1
    }
    else if (!is.null(set_metadata)) {
        matrix_and_mainbar_right <- set_metadata$ncols + 100
        matrix_and_mainbar_left <- set_metadata$ncols + 21
        size_bar_right <- set_metadata$ncols + 20
        size_bar_left <- set_metadata$ncols + 1
        metadata_right <- set_metadata$ncols
        metadata_left <- 1
    }
    if (newpage) {
        grid::grid.newpage()
    }
    if ((!is.null(legend)) && (query_legend != tolower("none"))) {
        if (query_legend == tolower("top")) {
            pushViewport(viewport(layout = grid.layout(102, matrix_and_mainbar_right)))
        }
        else if (query_legend == tolower("bottom")) {
            pushViewport(viewport(layout = grid.layout(103, matrix_and_mainbar_right)))
        }
    }
    else if ((is.null(legend)) || (query_legend == tolower("none"))) {
        pushViewport(viewport(layout = grid.layout(100, matrix_and_mainbar_right)))
    }
    # Modified
    vp = UpSetR:::vplayout(top:bottom, 1:(matrix_and_mainbar_right-matrix_and_mainbar_left))
    pushViewport(vp)
    grid.draw(arrangeGrob(Main_bar_plot, Matrix_plot, heights = hratios))
    popViewport()
    # Modified
    vp = UpSetR:::vplayout(size_plot_height:bottom, (matrix_and_mainbar_right-matrix_and_mainbar_left-1):96)
    pushViewport(vp)
    grid.draw(arrangeGrob(Size_plot))
    popViewport()
    if (!is.null(set_metadata)) {
        for (i in 1:length(set_metadata_plots)) {
            if (i != 1) {
                metadata_left <- 1 + metadata_right
                metadata_right <- metadata_right + set_metadata$plots[[i]]$assign
            }
            else {
                metadata_left <- 1
                metadata_right <- set_metadata$plots[[i]]$assign
            }
            vp = UpSetR:::vplayout(size_plot_height:bottom, metadata_left:metadata_right)
            pushViewport(vp)
            grid.draw(arrangeGrob(set_metadata_plots[[i]]))
            popViewport()
        }
    }
    if ((!is.null(legend)) && (query_legend != tolower("none"))) {
        vp = UpSetR:::vplayout(legend_top:legend_bottom, matrix_and_mainbar_left:matrix_and_mainbar_right)
        pushViewport(vp)
        grid.draw(arrangeGrob(legend))
        popViewport()
    }
}

Make_size_plot <- function (Set_size_data, sbar_color, ratios, ylabel, scale_sets, 
    text_scale, set_size_angle, set_size.show, set_size.scale_max, 
    set_size.number_size) {
    if (length(text_scale) > 1 && length(text_scale) <= 6) {
        x_axis_title_scale <- text_scale[3]
        x_axis_tick_label_scale <- text_scale[4]
    }
    else {
        x_axis_title_scale <- text_scale
        x_axis_tick_label_scale <- text_scale
    }
    if (ylabel == "Set Size" && scale_sets != "identity") {
        ylabel <- paste("Set Size", paste0("( ", 
            scale_sets, " )"))
        if (scale_sets == "log2") {
            Set_size_data$y <- log2(Set_size_data$y)
        }
        if (scale_sets == "log10") {
            Set_size_data$y <- log10(Set_size_data$y)
        }
    }
    if (!is.null(set_size.number_size)) {
        num.size <- (set_size.number_size/2.845276) * x_axis_tick_label_scale
    }
    else {
        num.size <- (7/2.845276) * x_axis_tick_label_scale
    }
    Size_plot <- (ggplot(data = Set_size_data, aes_string(x = "x", 
        y = "y")) + geom_bar(stat = "identity", colour = sbar_color, 
        width = 0.4, fill = sbar_color, position = "identity") + 
        scale_x_continuous(limits = c(0.5, (nrow(Set_size_data) + 
            0.5)), breaks = c(0, max(Set_size_data)), expand = c(0, 
            0)) + theme(panel.background = element_rect(fill = "white"), 
        plot.margin = unit(c(-0.11, -1.3, 0.5, 0.5), "lines"), 
        axis.title.x = element_text(size = 8.3 * x_axis_title_scale), 
        axis.text.x = element_text(size = 7 * x_axis_tick_label_scale, 
            vjust = 1, hjust = 0.5), axis.line = element_line(colour = "gray0"), 
        axis.line.y = element_blank(), axis.line.x = element_line(colour = "gray0", 
            size = 0.3), axis.text.y = element_blank(), axis.ticks.y = element_blank(), 
        panel.grid.minor = element_blank(), panel.grid.major = element_blank()) + 
        xlab(NULL) + ylab(ylabel) + coord_flip())
    if (set_size.show == TRUE) {
        Size_plot <- (Size_plot + geom_text(aes(label = y, vjust = 0.5, 
            hjust = 1.2, angle = set_size_angle), size = num.size))
    }
    if (scale_sets == "log10") {
        if (!is.null(set_size.scale_max)) {
            Size_plot <- (Size_plot + scale_y_continuous(limits = c(set_size.scale_max, 
                0), trans = log10_reverse_trans()))
        }
        else {
            Size_plot <- (Size_plot + scale_y_continuous(trans = log10_reverse_trans()))
        }
    }
    else if (scale_sets == "log2") {
        if (!is.null(set_size.scale_max)) {
            Size_plot <- (Size_plot + scale_y_continuous(limits = c(set_size.scale_max, 
                0), trans = log2_reverse_trans()))
        }
        else {
            Size_plot <- (Size_plot + scale_y_continuous(trans = log2_reverse_trans()))
        }
    }
    else {
        if (!is.null(set_size.scale_max)) {
            Size_plot <- (Size_plot + scale_y_continuous(limits = c(set_size.scale_max, 
                0), trans = "reverse"))
        }
        else {
            # Modified
            #Size_plot <- (Size_plot + scale_y_continuous(trans = "reverse"))
        }
    }
    Size_plot <- ggplot_gtable(ggplot_build(Size_plot))
    return(Size_plot)
}

assignInNamespace(x="NoAttBasePlot", value=NoAttBasePlot, ns="UpSetR")
assignInNamespace(x="Make_size_plot", value=Make_size_plot, ns="UpSetR")
```

```{r, width = 800, height = 500}
gg_miss_upset(subdata, nintersects = NA, text.scale = 1)
```

We directly delete the data with missing values.

```{r}

```

```{r}
newdata <- na.omit(subdata)
```
